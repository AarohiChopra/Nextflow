# -*- coding: utf-8 -*-
"""extractFileForPipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15wSPny5moGvfeKUypmTJrGZOdC6Gd7tR
"""

import argparse
import pandas as pd
import os
import re
#df = pd.read_table("/content/combined_feature_counts_new.txt", sep='\t', comment='#', skiprows=1).set_index("Geneid").drop(columns = ["Chr","Start","End","Strand","Length"])
#df.columns = ["SRR21043406","SRR21043571","SRR21043800","SRR21043957","SRR21043509","SRR21043270","SRR21043508","SRR21043510"]

# SRR21043510SC.bam	SRR21043270SC.bam	SRR21043955SC.bam	SRR21043508SC.bam	SRR21043798SC.bam	SRR21043509SC.bam	SRR21043569SC.bam	SRR21043404SC.bam
#lis = [ a.replace("SC.bam", "") for a in df.columns]

#df.columns = lis

parser = argparse.ArgumentParser(description="Extract count and condition files for Nextflow pipeline")
parser.add_argument("--counts", required=True, help="Path to the combined feature counts file")
parser.add_argument("--conc", required=True, help="Conc (treatment) name")
parser.add_argument("--chemical", required=True, help="Chemical (treatment) name")
parser.add_argument("--control", required=True, help="Control name")
parser.add_argument("--outdir", default=".", help="Output directory")
args = parser.parse_args()

#df.to_csv("counts_file.txt",header=None, index=None, sep=' ')
df = pd.read_table(args.counts, sep="\t", comment="#").drop(columns = ["Start","End","Strand","Length", "Chr"])
#df.to_csv("new_featurecount_counts_file.txt",header=None, index=None, sep=' ')
df.columns = list(a.replace("SC.bam", "") for a in df.columns)
df.shape

import pandas as pd
conditions = pd.read_csv("/scratch/home/achopra/BPA_Alt_Human/BPA/De_Seq/condition.csv")
counts = df
counts.columns = list(a.replace("SC.bam", "") for a in df.columns)
# print(len({a.split("[")[0] for a in conditions.condition.unique()}))
conditions.condition = conditions.condition.str.strip()
Batch = pd.read_csv("/scratch/home/achopra/BPA_Alt_Human/BPA/De_Seq/batch.csv")
#sorted(conditions.condition.unique())
#sorted(conditions.condition.to_list())

import random
import pandas as pd

# Input for treatment group and concentration
# treatment = str(input("Enter the treatment group you want to analyze: "))
treatment = str(args.chemical).strip()
#concentration = r"\["+str(input("Do you want to specify concentration? Enter Q or the concentration value: "))+ r"\]"
concentration = str(args.conc).strip()

# Initialize the condition_treatment and condition_control
condition_treatment = ""
condition_control = "Control"

# Handling concentration input
if "Q" in concentration.upper():
    print("No concentration specified.")
    treatment_dict = (
        conditions[conditions['condition'].str.contains(treatment, case=False, na=False)]
        .set_index('x')['condition']
        .to_dict()
    )
else:
    # Normalize and build an exact regex for [10], not [100] or [0.1]
    conc_clean = concentration.strip("[]")
    conc_pattern = rf"\[{re.escape(conc_clean)}\](?![\d\.])"  # [10] not followed by digits or dot
    treatment_dict = (
        conditions[
            conditions['condition'].str.contains(treatment, case=False, na=False) &
            conditions['condition'].str.contains(conc_pattern, case=False, regex=True, na=False)
        ]
        .set_index('x')['condition']
        .to_dict()
    )

print(treatment_dict)

# Input for control group
#control = str(input("Enter the control group you want to compare with: "))
control = str(args.control)
control_samples = conditions[conditions['condition'].str.contains(control, case=False, na=False)]['x'].to_list()
if(control == "DMSO" and len(treatment_dict) == 4):
  control_samples = ["SRR21043816","SRR21043814","SRR21043817","SRR21043815"]
if(("treat" in str(control)) and len(treatment_dict) == 4):
  control_samples = ["SRR21043271","SRR21043269","SRR21043270","SRR21043403"]
copy = treatment_dict.copy()
'''
for i in copy:
  if(str(Batch[Batch.Run == i]["batch"].to_list()[0]) == "Plate 1B index G"):
    print("remove")
    del treatment_dict[i]
copy = control_samples.copy()
for i in copy:
  if(str(Batch[Batch.Run == i]["batch"].to_list()[0]) == "Plate 1B index G"):
    print("remove")
    control_samples.remove(i)
'''
if(len(treatment_dict) < len(control_samples)):
  print("AHHH")
  counts_for_treatment = len(treatment_dict)
  control_samples = random.sample(control_samples, counts_for_treatment)

# Combine treatment and control samples in the same consistent order
filter = ["Geneid"] + list(treatment_dict.keys()) + control_samples

# Filter the counts dataframe to keep only the selected samples (excluding "Geneid")
print(filter)
filter_df = counts[filter]

# Save the filtered counts to a CSV file
filter_df.to_csv("counts_file.csv", index=False)

# Combine treatment and control for consistent ordering
filtered_samples =  list(treatment_dict.keys())  + control_samples

# Filter the batch information for the selected samples
batch_filtered = Batch[Batch['Run'].isin(filtered_samples)]

# Ensure consistent ordering in batch file (treatment first, then control)
batch_filtered = batch_filtered.set_index('Run').loc[filtered_samples].reset_index()

# Save the filtered batch information to a CSV file
batch_filtered.to_csv("batch_file.csv", index=False)



condition_list = treatment_dict.copy()
# Append the control condition for each sample in the control group
for i in control_samples:
    condition_list[i] = control
print(condition_list)

condition_df = pd.DataFrame.from_dict(condition_list, orient='index').reset_index()
condition_df.columns = ['x', 'condition']

# Save the condition file as a tab-separated text file
condition_df.to_csv("condition_file.txt", sep='\t', index=False)


'''
for i in copy:
  if(str(Batch[Batch.Run == i]["batch"].to_list()[0]) == "Plate 1B index G"):
    print("remove")
    del treatment_dict[i]
copy = control_samples.copy()
for i in copy:
  if(str(Batch[Batch.Run == i]["batch"].to_list()[0]) == "Plate 1B index G"):
    print("remove")
    control_samples.remove(i)
'''

